/* Problem 1: Multiples of 3 and 5Passed

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below the provided parameter value number. */
function multiplesOf3and5(number) {
  let multiples = [], index = number - 1;
  while (index > 0) {
    if (index % 3 === 0 || index % 5 === 0) {
      multiples.push(index);
      index--;
    } else {
      index--;
    }
  }
  console.log(multiples);
  return multiples.reduce( (a, b) => a + b);
}
//console.log(multiplesOf3and5(1000));

/* Problem 2: Even Fibonacci Numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence that do not exceed the nth term, find the sum of the even-valued terms. */
function fiboEvenSum(number) {
  let terms = new Array(number), index = 2;
  terms[0] = 1;
  terms[1] = 2;
  // if number is less than higest number in starting terms array
  if (number <= terms[1]) return terms[1]; 
  while (index < number) {
    terms[index] = terms[index - 1] + terms[index - 2];
    index++;
  }
  return terms.filter( x => x % 2 === 0).reduce( (a,b) => a + b);
}
//console.log(fiboEvenSum(23));  //60696

/* Problem 3: Largest prime factor

The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the given number? */

// First attempt
function prime(number) {
  let prime = false, factor = 2;
  for (factor; factor <= number; factor++) {
    if (number / factor === 1) {
      prime = true;
    } else if (number % factor !== 0) {
      continue;
    } else {
      break;
    }
  }
  return prime;
}

function largestPrimeFactor(number) {
  let primes = [];
  function breakdown(number, count = 2) {
    for (count; count <= number; count++) {
      if (number === count && prime(count)) {
        console.log("1, number: " + number + ", count: " + count);
        primes.push(count);
        break;
      }
      if (number % count === 0) {
        number = number / count;
        if (prime(count) && prime(number)) {
          primes.push(count);
          primes.push(number);
          break;
        } 
        if (prime(count) && !prime(number)) {
          primes.push(count);
          breakdown(number, count);
          break;
        } else {
          breakdown(count);
          break;
        }
      }
    }
  }
  breakdown(number);
  console.log(primes)
  return Math.max(...primes);
}
//console.log(largestPrimeFactor(24));  //6875

// Second Attempt
function largestPFactor(number) {
  let largest, factor = 2;
  for (factor; factor <= number; factor++) {
    //console.log(`number: ${number}, factor: ${factor}`)
    if (number % factor === 0) {
      largest = factor;
      number = number / largest;
      //console.log(`largest: ${largest}, number: ${number}`)
      factor--;  // keep factor the same to check next number
    }
  }
  return largest;
}
//console.log(largestPFactor(24));


/* Project Euler: Problem 4: Largest palindrome product

A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
Find the largest palindrome made from the product of two n-digit numbers. */
// First attempt
function largestPalindromeProduct(n) {
  function startingNumber(length) {
    let num = []
    for (let i = 0; i < length; i++) {
      num.push("9");
    }
    return Number(num.join(""));
  }
  let number1 = startingNumber(n);
  let number2 = startingNumber(n);

  function palindrome(num) {
    let result = true;
    let numArr = num.toString().split("").map(Number);
    let start = 0;
    let end = num.toString().split("").length;
    for (start; start <= Math.floor(end / start); start++) {
      let check = end - 1 - start;
      if (numArr[start] === numArr[check]) {
        continue;
      } else {
        result = false;
        break;
      }
    }
    return result;
  }
  
  let result = null;
  for (number1; number1 >= 0; number1--) {
    
    for (number2; number2 >= 0; number2--) {
      let value = number1 * number2;
      
      if (palindrome(value)) {
        //console.log(`number1: ${number1}, number2: ${number2}, value: ${value}`);
        if (result < value) result = value;
        break;
      }
    }
    number2 = number1;
  }
  return result;
}
//console.log(largestPalindromeProduct(3));

// Second Attempt (shorten)
function largestPalProduct(n) {
  function highest(length) {
    let num = []
    for (let i = 0; i < length; i++) {
      num.push("9");
    }
    return Number(num.join(""));
  }
  let highNum = highest(n);
  
  let result = null, number1 = highNum, number2 = highNum;
  for (number1; number1 >= 0; number1--) {
    for (number2; number2 >= 0; number2--) {
      let value = number1 * number2;
      let reverse = Number(new String(value).split("").reverse().join(""));
      if (reverse === value) {
        if (result < value) {
          result = value;
          break;
        }
      }
    }
    number2 = number1;
  }
  return result;
}
//console.log(largestPalProduct(3)); //906609

/* Project Euler: Problem 5: Smallest multiple

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to n? */
// 1st attempt
function smallestMult(n) {
  let numerator = n;
  let denomenator = n;
  for (numerator; ; numerator++) {
    for (denomenator; denomenator > 0; denomenator--) {
      if (numerator % denomenator === 0) continue;
      else break;
    }
    if (denomenator === 0) {
      break;
    } else {
      denomenator = n;
      continue;
    }
  }
  return numerator;
}
//console.log(smallestMult(20));
// 2nd attempt, longer but much faster
function smallestMultiple(n) {
  function lcm(a, b) {
    function getPrimes(number) {
      let primes = [], factor = 2;
      for (factor; factor <= number; factor++) {
        if (number % factor === 0) {
          primes.push(factor);
          number = number / Math.max(...primes);
          factor--;  // keep factor the same to check next number
        }
      }
      return primes;
    }

    let aPrimes = getPrimes(a);
    let bPrimes = getPrimes(b);
    let longestArr = aPrimes.length >= bPrimes.length ? aPrimes.length : bPrimes.length;
    let lcmArr = [];
    for (let i = 0; i < longestArr; i++) {
      if (aPrimes[i] === bPrimes[i]) {
        lcmArr.push(aPrimes[i]);
        aPrimes.shift();
        bPrimes.shift();
        i--;
        longestArr = aPrimes.length >= bPrimes.length ? aPrimes.length : bPrimes.length;
      }
      if (aPrimes[i] - bPrimes[i] > 0) {
        lcmArr.push(bPrimes[i]);
        bPrimes.shift();
        i--;
        longestArr = aPrimes.length >= bPrimes.length ? aPrimes.length : bPrimes.length;
      }
      if (aPrimes[i] - bPrimes[i] < 0) {
        lcmArr.push(aPrimes[i]);
        aPrimes.shift();
        i--;
        longestArr = aPrimes.length >= bPrimes.length ? aPrimes.length : bPrimes.length;
      }
    }
    let concatArrs = lcmArr.concat(aPrimes, bPrimes);
    return concatArrs.reduce( (a, b) => a * b);
  }

  let multiples, a = 1, b = 2;
  while (b <= n) {
    let multiple = lcm(a, b);
    multiples = multiple;
    a = multiple;
    b++;
  }
  return multiples;
} 
//console.log(smallestMultiple(20));